<!DOCTYPE html>
<html xml:lang="zh-CN" lang="zh-CN">

<head>
        <link rel="canonical" href="https://freesurfboard.github.io/news/article-75330.htm" />
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>springboot集成elasticsearch注意事项</title>
        <meta name="description" content="一、elasticsearch基础 &nbsp;　　这里假设各位已经简单了解过elasticsearch，并不对es进入更多的，更深层次的解释，如有必要，会在写文章专门进行es讲解。 　　Elasti" />
        <link rel="icon" href="/assets/website/img/freesurfboard/favicon.ico" type="image/x-icon"/>

    <meta name="author" content="Free Surfboard官方订阅站">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://freesurfboard.github.io/news/article-75330.htm" />
    <meta property="og:site_name" content="Free Surfboard官方订阅站" />
    <meta property="og:title" content="springboot集成elasticsearch注意事项" />
    <meta property="og:image" content="https://freesurfboard.github.io/uploads/20240726-2/c698124a127c44fd2a9c33606c5a9dee.webp" />
        <meta property="og:release_date" content="2025-03-17T09:38:32" />
    <meta property="og:updated_time" content="2025-03-17T09:38:32" />
        <meta property="og:description" content="一、elasticsearch基础 &nbsp;　　这里假设各位已经简单了解过elasticsearch，并不对es进入更多的，更深层次的解释，如有必要，会在写文章专门进行es讲解。 　　Elasti" />
        
    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="springboot集成elasticsearch注意事项">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&family=Poppins:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,600;0,700;1,300;1,400;1,600;1,700&display=swap" rel="stylesheet">
    <!-- Vendor CSS Files -->
    <link href="/assets/website/js/frontend/freesurfboard/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/website/js/frontend/freesurfboard/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
    <link href="/assets/website/js/frontend/freesurfboard/aos/aos.css" rel="stylesheet">
    <link href="/assets/website/js/frontend/freesurfboard/glightbox/css/glightbox.min.css" rel="stylesheet">
    <link href="/assets/website/js/frontend/freesurfboard/swiper/swiper-bundle.min.css" rel="stylesheet">
    <!-- Variables CSS Files. Uncomment your preferred color scheme -->
    <link href="/assets/website/css/freesurfboard/variables.css" rel="stylesheet">
    <!-- Template Main CSS File -->
    <link href="/assets/website/css/freesurfboard/main.css" rel="stylesheet">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-GEDHRZQGGF"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GEDHRZQGGF');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
    <!-- ======= Header ======= -->
    <header id="header" class="header fixed-top" data-scrollto-offset="0">
        <div class="container-fluid d-flex align-items-center justify-content-between">
            <a href="/" class="logo d-flex align-items-center scrollto me-auto me-lg-0">
                        <span>Free Surfboard</span>
                        </a>
            <nav id="navbar" class="navbar">
                <ul>
                                        <li><a class="nav-link" href="/">首页</a></li>
                                        <li><a class="nav-link" href="/free-nodes/">免费节点</a></li>
                                        <li><a class="nav-link" href="/paid-subscribe/">推荐机场</a></li>
                                        <li><a class="nav-link" href="/client.htm">客户端</a></li>
                                        <li><a class="nav-link" href="/news/">新闻资讯</a></li>
                                    </ul>
                <i class="bi bi-list mobile-nav-toggle d-none"></i>
            </nav><!-- .navbar -->
        </div>
    </header><!-- End Header -->
    <main id="main">
        <!-- ======= Breadcrumbs ======= -->
        <div class="breadcrumbs">
            <div class="container">
                <div class="d-flex justify-content-between align-items-center">
                    <h1>springboot集成elasticsearch注意事项</h1>
                    <ol>
                        <li><a href="/">首页</a></li>
                        <li><a href="/news/">新闻资讯</a></li>
                        <li>正文</li>
                    </ol>
                </div>
            </div>
        </div><!-- End Breadcrumbs -->
        <!-- ======= About Section ======= -->
        <section id="about" class="about">
            <div class="container" data-aos="fade-up">
                <div class="row">
                    <div class="col-md-9">
                                        <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				<div id="content_views" class="htmledit_views"> <h3>一、elasticsearch基础</h3> <p>&nbsp;　　这里假设各位已经简单了解过elasticsearch，并不对es进入更多的，更深层次的解释，如有必要，会在写文章专门进行es讲解。</p> <p>　　Elasticsearch是一个基于<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://lucene.apache.org/core/"  rel="nofollow">Apache Lucene(TM)</a>的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p> <p>　　但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</p> <p>　　Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的<code>RESTful API</code>来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p> <p>&nbsp;　　index ==》索引 ==》Mysql中的一个库，库里面可以建立很多表，存储不同类型的数据，而表在ES中就是type。</p> <p>　　 type&nbsp;==》类型&nbsp;==》相当于Mysql中的一张表，存储json类型的数据</p> <p>　　 document&nbsp; ==》文档&nbsp;==》一个文档相当于Mysql一行的数据</p> <p>　　 field&nbsp;==》列&nbsp;==》相当于mysql中的列，也就是一个属性</p> <p><strong>这里多说下：</strong></p> <p>在Elasticsearch6.0.0或者或者更新版本中创建的索引只会包含一个映射类型（mappingtype）。在5.x中创建的具有多个映射类型的索引在Elasticsearch6.x中依然会正常工作。在Elasticsearch7.0.0中，映射类型type将会被完全移除。</p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.elastic.co/guide/en/elasticsearch/reference/current/removal-of-types.html"  rel="nofollow">原文链接</a></p> <p>　　开始的时候，我们说“索引（index）”类似于SQL数据库中的“数据库”，将“类型（type）”等同于“表”。</p> <p>　　这是一个糟糕的类比，并且导致了一些错误的假设。在SQL数据库中，表之间是相互独立的。一个表中的各列并不会影响到其它表中的同名的列。而在映射类型（mappingtype）中却不是这样的。</p> <p>&nbsp;　　在同一个Elasticsearch索引中，其中不同映射类型中的同名字段在内部是由同一个Lucene字段来支持的。换句话说，使用上面的例子，user类型中的user_name字段与tweet类型中的user_name字段是完全一样的，并且两个user_name字段在两个类型中必须具有相同的映射（定义）。</p> <p>&nbsp;　　这会在某些情况下导致一些混乱，比如，在同一个索引中，当你想在其中的一个类型中将deleted字段作为date类型，而在另一个类型中将其作为boolean字段。</p> <p>&nbsp;　　在此之上需要考虑一点，如果同一个索引中存储的各个实体如果只有很少或者根本没有同样的字段，这种情况会导致稀疏数据，并且会影响到Lucene的高效压缩数据的能力。</p> <p>&nbsp;　　基于这些原因，将映射类型的概念从Elasticsearch中移除。</p> <h3>二、springboot 对应的Es版本关系</h3> <table> <thead> <tr> <th>springboot</th> <th>elasticsearch</th> </tr> </thead> <tbody> <tr> <td>2.0.0.RELEASE</td> <td>2.2.0</td> </tr> <tr> <td>1.4.0.M1</td> <td>1.7.3</td> </tr> <tr> <td>1.3.0.RELEASE</td> <td>1.5.2</td> </tr> <tr> <td>1.2.0.RELEASE</td> <td>1.4.4</td> </tr> <tr> <td>1.1.0.RELEASE</td> <td>1.3.2</td> </tr> <tr> <td>1.0.0.RELEASE</td> <td>1.1.1</td> </tr> </tbody> </table> <p>　　1、None of the configured nodes are available 或者org.elasticsearch.transport.RemoteTransportException: Failed to deserialize exception response from stream</p> <p>　　原因：spring data elasticSearch 的版本与Spring boot、Elasticsearch版本不匹配。</p> <p>这是版本之间的对应关系。Spring boot 1.3.5默认的elasticsearch版本是1.5.2，此时启动1.7.2版本以下的Elasticsearch客户端连接正常。</p> <p>　　注：注意java的es默认连接端口是9300，9200是http端口，这两个在使用中应注意区分。</p> <p>　　2、Caused by: java.lang.IllegalArgumentException: @ConditionalOnMissingBean annotations must specify at least one bean (type, name or annotation)</p> <p>　　原因：spring boot是1.3.x版本，而es采用了2.x版本。在es的2.x版本去除了一些类，而这些类在spring boot的1.3.x版本中仍然被使用，导致此错误</p> <p><strong>&nbsp;以上解决参考下面的对应关系</strong>：</p> <table> <thead> <tr> <th>Spring Boot Version (x)</th> <th>Spring Data Elasticsearch Version (y)</th> <th>Elasticsearch Version (z)</th> </tr> </thead> <tbody> <tr> <td>x &lt;= 1.3.5</td> <td>y &lt;= 1.3.4</td> <td>z &lt;= 1.7.2*</td> </tr> <tr> <td>x &gt;= 1.4.x</td> <td>2.0.0 &lt;=y &lt; 5.0.0**</td> <td>2.0.0 &lt;= z &lt; 5.0.0**</td> </tr> </tbody> </table> <p>　　　请一定注意版本兼容问题。这关系到很多maven依赖。<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://github.com/spring-projects/spring-data-elasticsearch/wiki/Spring-Data-Elasticsearch---Spring-Boot---version-matrix"  rel="nofollow">Spring Data Elasticsearch Spring Boot version matrix</a></p> <p><strong>ik 分词对应的版本关系：</strong></p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://github.com/medcl/elasticsearch-analysis-ik"  rel="nofollow">elasticsearch-analysis-ik</a></p> <p><strong>Analyzer:</strong></p> <p><strong><code>ik_smart</code>&nbsp;,<code>ik_max_word</code>&nbsp;, Tokenizer:<code>ik_smart</code>&nbsp;,<code>ik_max_word</code></strong></p> <p><strong>Versions</strong></p> <table> <thead> <tr> <th>IK version</th> <th>ES version</th> </tr> </thead> <tbody> <tr> <td>master</td> <td>6.x -&gt; master</td> </tr> <tr> <td>6.2.2</td> <td>6.2.2</td> </tr> <tr> <td>6.1.3</td> <td>6.1.3</td> </tr> <tr> <td>5.6.8</td> <td>5.6.8</td> </tr> <tr> <td>5.5.3</td> <td>5.5.3</td> </tr> <tr> <td>5.4.3</td> <td>5.4.3</td> </tr> <tr> <td>5.3.3</td> <td>5.3.3</td> </tr> <tr> <td>5.2.2</td> <td>5.2.2</td> </tr> <tr> <td>5.1.2</td> <td>5.1.2</td> </tr> <tr> <td>1.10.6</td> <td>2.4.6</td> </tr> <tr> <td>1.9.5</td> <td>2.3.5</td> </tr> <tr> <td>1.8.1</td> <td>2.2.1</td> </tr> <tr> <td>1.7.0</td> <td>2.1.1</td> </tr> <tr> <td>1.5.0</td> <td>2.0.0</td> </tr> <tr> <td>1.2.6</td> <td>1.0.0</td> </tr> <tr> <td>1.2.5</td> <td>0.90.x</td> </tr> <tr> <td>1.1.3</td> <td>0.20.x</td> </tr> <tr> <td>1.0.0</td> <td>0.16.2 -&gt; 0.19.0</td> </tr> </tbody> </table> <h3>三、环境构建</h3> <p>maven依赖：前提是依赖</p> <pre class="has"><code class="language-html">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt;  &lt;dependency&gt;       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;       &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre> <p>配置文件：</p> <table border="0" cellpadding="0" cellspacing="0"> <tbody> <tr> <td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> </td> <td> <p><code># ES</code></p> <p><code>#开启 Elasticsearch 仓库(默认值:true)</code></p> <p><code>spring.data.elasticsearch.repositories.enabled=true</code></p> <p><code>#默认 9300 是 Java 客户端的端口。9200 是支持 Restful HTTP 的接口</code></p> <p><code>spring.data.elasticsearch.cluster-nodes = 127.0.0.1:9300</code></p> <p><code>#spring.data.elasticsearch.cluster-name Elasticsearch 集群名(默认值: elasticsearch)</code></p> <p><code>#spring.data.elasticsearch.cluster-nodes 集群节点地址列表，用逗号分隔。如果没有指定，就启动一个客户端节点</code></p> <p><code>#spring.data.elasticsearch.propertie 用来配置客户端的额外属性</code></p> <p><code>#存储索引的位置</code></p> <p><code>spring.data.elasticsearch.properties.path.home=/data/project/target/elastic</code></p> <p><code>#连接超时的时间</code></p> <p><code>spring.data.elasticsearch.properties.transport.tcp.connect_timeout=120s</code></p> </td> </tr> </tbody> </table> <h3>&nbsp;四、es索引实体类</h3> <p>Spring-data-elasticsearch为我们提供了<strong><code>@Document</code>、<code>@Field</code></strong>等注解，如果某个实体需要建立索引，只需要加上这些注解即可</p> <p>1.类上注解：@Document (相当于Hibernate实体的@Entity/@Table)(必写)，加上了<code>@Document</code>注解之后，默认情况下这个实体中所有的属性都会被建立索引、并且分词。</p> <table> <thead> <tr> <th>类型</th> <th>属性名</th> <th>默认值</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>String</td> <td>indexName</td> <td>无</td> <td>索引库的名称，建议以项目的名称命名</td> </tr> <tr> <td>String</td> <td>type</td> <td>“”</td> <td>类型，建议以实体的名称命名</td> </tr> <tr> <td>short</td> <td>shards</td> <td>5</td> <td>默认分区数</td> </tr> <tr> <td>short</td> <td>replica</td> <td>1</td> <td>每个分区默认的备份数</td> </tr> <tr> <td>String</td> <td>refreshInterval</td> <td>“1s”</td> <td>刷新间隔</td> </tr> <tr> <td>String</td> <td>indexStoreType</td> <td>“fs”</td> <td>索引文件存储类型</td> </tr> </tbody> </table> <p>2.主键注解：@Id (相当于Hibernate实体的主键@Id注解)(必写)</p> <p>只是一个标识，并没有属性。</p> <p>3.属性注解 @Field (相当于Hibernate实体的@Column注解)</p> <p><strong>@Field默认是可以不加的，默认所有属性都会添加到ES中。加上@Field之后，@document默认把所有字段加上索引失效，只有家@Field 才会被索引(同时也看设置索引的属性是否为no)</strong></p> <table> <thead> <tr> <th>类型</th> <th>属性名</th> <th>默认值</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>FieldType</td> <td>type</td> <td>FieldType.Auto</td> <td>自动检测属性的类型</td> </tr> <tr> <td>FieldIndex</td> <td>index</td> <td>FieldIndex.analyzed</td> <td>默认情况下分词</td> </tr> <tr> <td>boolean</td> <td>store</td> <td>false</td> <td>默认情况下不存储原文</td> </tr> <tr> <td>String</td> <td>searchAnalyzer</td> <td>“”</td> <td>指定字段搜索时使用的分词器</td> </tr> <tr> <td>String</td> <td>indexAnalyzer</td> <td>“”</td> <td>指定字段建立索引时指定的分词器</td> </tr> <tr> <td>String[]</td> <td>ignoreFields</td> <td>{}</td> <td>如果某个字段需要被忽略</td> </tr> </tbody> </table> <h3>五、相关查询方法</h3> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/"  rel="nofollow">官网参考</a></p> <p>　　实现方式比较多，已经存在的接口，使用根据需要继承即可：</p> <p>　　1、CrudRepository接口</p> <pre class="has"><code class="language-html">public interface CrudRepository&lt;T, ID extends Serializable&gt;   extends Repository&lt;T, ID&gt; {    &lt;S extends T&gt; S save(S entity);          Optional&lt;T&gt; findById(ID primaryKey);     Iterable&lt;T&gt; findAll();                   long count();                            void delete(T entity);                   boolean existsById(ID primaryKey);       // … more functionality omitted. }</code></pre> <p>　　2、PagingAndSortingRepository接口</p> <pre class="has"><code class="language-html">public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt;   extends CrudRepository&lt;T, ID&gt; {    Iterable&lt;T&gt; findAll(Sort sort);    Page&lt;T&gt; findAll(Pageable pageable); }</code></pre> <p>&nbsp;例子：</p> <p>分页：</p> <pre class="has"><code class="language-html">PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean Page&lt;User&gt; users = repository.findAll(new PageRequest(1, 20));</code></pre> <p>计数：</p> <pre class="has"><code class="language-html">interface UserRepository extends CrudRepository&lt;User, Long&gt; {    long countByLastname(String lastname); }</code></pre> <p>　　3、其他，参考官网</p> <p><strong>自定义查询实现</strong></p> <p><strong>那么我们如何自定义方法呢？我们只要使用特定的单词对方法名进行定义，那么Spring就会对我们写的方法名进行解析，</strong></p> <p><strong>该机制条前缀<code>find…By</code>，<code>read…By</code>，<code>query…By</code>，<code>count…By</code>，和<code>get…By</code>从所述方法和开始分析它的其余部分。引入子句可以包含进一步的表达式，如<code>Distinct</code>在要创建的查询上设置不同的标志。然而，第一个<code>By</code>作为分隔符来指示实际标准的开始。在非常基础的层次上，您可以定义实体属性的条件并将它们与<code>And</code>和连接起来<code>Or</code>。</strong></p> <pre class="has"><code class="language-html">interface PersonRepository extends Repository&lt;User, Long&gt; {    List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);    // Enables the distinct flag for the query   List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);   List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);    // Enabling ignoring case for an individual property   List&lt;Person&gt; findByLastnameIgnoreCase(String lastname);   // Enabling ignoring case for all suitable properties   List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);    // Enabling static ORDER BY for a query   List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);   List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname); }</code></pre> <p><strong>　　构建查询属性算法原理</strong>：</p> <p>如上例所示。在查询创建时，确保解析的属性是托管类的属性。但是，你也可以通过遍历嵌套属性来定义约束。假设<code>Person x</code>有一个<code>Address</code>和<code>ZipCode</code>。在这种情况下，方法名称为</p> <pre class="has"><code class="language-html">List&lt;Person&gt; findByAddressZipCode(ZipCode zipCode);</code></pre> <p>创建属性遍历<code>x.address.zipCode</code>。解析算法首先将整个part（<code>AddressZipCode</code>）作为属性进行解释，然后检查具有该名称属性的类。如果皮匹配成功，则使用该属性。如果不是属性，则算法拆分从右侧的驼峰部分头部和尾部，并试图找出相应的属性，在我们的例子，<code>AddressZip</code>和<code>Code</code>。如果算法找到具有该头部的属性，它将采用尾部并继续从那里构建树，然后按照刚刚描述的方式分割尾部。如果第一个分割不匹配，则算法将分割点移动到左侧（<code>Address</code>，<code>ZipCode</code>）并继续。</p> <p>虽然这应该适用于大多数情况，但算法仍可能会选择错误的属性。假设这个<code>Person</code>类也有一个<code>addressZip</code>属性。该算法将在第一轮拆分中匹配，并且基本上选择错误的属性并最终失败（因为<code>addressZip</code>可能没有<code>code</code>属性的类型）。</p> <p>为了解决这个歧义，你可以<code>\_</code>在你的方法名称中使用手动定义遍历点。所以我们的方法名称会像这样结束：</p> <pre class="has"><code class="language-html">List&lt;Person&gt; findByAddress_ZipCode(ZipCode zipCode);</code></pre> <pre class="has"><code class="language-html">由于我们将下划线视为保留字符，因此我们强烈建议遵循标准的Java命名约定（即，不要在属性名称中使用下划线，而应使用驼峰大小写）  其他分页查询</code></pre> <pre class="has"><code class="language-html">Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);  Slice&lt;User&gt; findByLastname(String lastname, Pageable pageable);  List&lt;User&gt; findByLastname(String lastname, Sort sort);</code></pre> <p><strong>也可以用Java8 Stream查询和sql语句查询</strong></p> <table border="0" cellpadding="0" cellspacing="0"> <tbody> <tr> <td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td> <td> <p><code>@Query</code><code>(</code><code>"select u from User u"</code><code>)</code></p> <p><code>Stream&lt;User&gt; findAllByCustomQueryAndStream();</code></p> <p><code>Stream&lt;User&gt; readAllByFirstnameNotNull();</code></p> <p><code>@Query</code><code>(</code><code>"select u from User u"</code><code>)</code></p> <p><code>Stream&lt;User&gt; streamAllPaged(Pageable pageable);</code></p> </td> </tr> </tbody> </table> <p><strong>有些在复杂的可以使用es查询语句</strong></p> <p>我们可以使用@Query注解进行查询，这样要求我们需要自己写ES的查询语句</p> <pre class="has"><code class="language-html">public interface BookRepository extends ElasticsearchRepository&lt;Book, String&gt; {     @Query("{"bool" : {"must" : {"field" : {"name" : "?0"}}}}")     Page&lt;Book&gt; findByName(String name,Pageable pageable); }</code></pre> <p><strong>方法和es查询转换：</strong></p> <table> <thead> <tr> <th>Keyword</th> <th>Sample</th> <th>Elasticsearch Query String</th> </tr> </thead> <tbody> <tr> <td> <p><code>And</code></p> </td> <td> <p><code>findByNameAndPrice</code></p> </td> <td> <p><code>{"bool" : {"must" : [ {"field" : {"name" : "?"}}, {"field" : {"price" : "?"}} ]}}</code></p> </td> </tr> <tr> <td> <p><code>Or</code></p> </td> <td> <p><code>findByNameOrPrice</code></p> </td> <td> <p><code>{"bool" : {"should" : [ {"field" : {"name" : "?"}}, {"field" : {"price" : "?"}} ]}}</code></p> </td> </tr> <tr> <td> <p><code>Is</code></p> </td> <td> <p><code>findByName</code></p> </td> <td> <p><code>{"bool" : {"must" : {"field" : {"name" : "?"}}}}</code></p> </td> </tr> <tr> <td> <p><code>Not</code></p> </td> <td> <p><code>findByNameNot</code></p> </td> <td> <p><code>{"bool" : {"must_not" : {"field" : {"name" : "?"}}}}</code></p> </td> </tr> <tr> <td> <p><code>Between</code></p> </td> <td> <p><code>findByPriceBetween</code></p> </td> <td> <p><code>{"bool" : {"must" : {"range" : {"price" : {"from" : ?,"to" : ?,"include_lower" : true,"include_upper" : true}}}}}</code></p> </td> </tr> <tr> <td> <p><code>LessThanEqual</code></p> </td> <td> <p><code>findByPriceLessThan</code></p> </td> <td> <p><code>{"bool" : {"must" : {"range" : {"price" : {"from" : null,"to" : ?,"include_lower" : true,"include_upper" : true}}}}}</code></p> </td> </tr> <tr> <td> <p><code>GreaterThanEqual</code></p> </td> <td> <p><code>findByPriceGreaterThan</code></p> </td> <td> <p><code>{"bool" : {"must" : {"range" : {"price" : {"from" : ?,"to" : null,"include_lower" : true,"include_upper" : true}}}}}</code></p> </td> </tr> <tr> <td> <p><code>Before</code></p> </td> <td> <p><code>findByPriceBefore</code></p> </td> <td> <p><code>{"bool" : {"must" : {"range" : {"price" : {"from" : null,"to" : ?,"include_lower" : true,"include_upper" : true}}}}}</code></p> </td> </tr> <tr> <td> <p><code>After</code></p> </td> <td> <p><code>findByPriceAfter</code></p> </td> <td> <p><code>{"bool" : {"must" : {"range" : {"price" : {"from" : ?,"to" : null,"include_lower" : true,"include_upper" : true}}}}}</code></p> </td> </tr> <tr> <td> <p><code>Like</code></p> </td> <td> <p><code>findByNameLike</code></p> </td> <td> <p><code>{"bool" : {"must" : {"field" : {"name" : {"query" : "?*","analyze_wildcard" : true}}}}}</code></p> </td> </tr> <tr> <td> <p><code>StartingWith</code></p> </td> <td> <p><code>findByNameStartingWith</code></p> </td> <td> <p><code>{"bool" : {"must" : {"field" : {"name" : {"query" : "?*","analyze_wildcard" : true}}}}}</code></p> </td> </tr> <tr> <td> <p><code>EndingWith</code></p> </td> <td> <p><code>findByNameEndingWith</code></p> </td> <td> <p><code>{"bool" : {"must" : {"field" : {"name" : {"query" : "*?","analyze_wildcard" : true}}}}}</code></p> </td> </tr> <tr> <td> <p><code>Contains/Containing</code></p> </td> <td> <p><code>findByNameContaining</code></p> </td> <td> <p><code>{"bool" : {"must" : {"field" : {"name" : {"query" : "<strong>?</strong>","analyze_wildcard" : true}}}}}</code></p> </td> </tr> <tr> <td> <p><code>In</code></p> </td> <td> <p><code>findByNameIn(Collection&lt;String&gt;names)</code></p> </td> <td> <p><code>{"bool" : {"must" : {"bool" : {"should" : [ {"field" : {"name" : "?"}}, {"field" : {"name" : "?"}} ]}}}}</code></p> </td> </tr> <tr> <td> <p><code>NotIn</code></p> </td> <td> <p><code>findByNameNotIn(Collection&lt;String&gt;names)</code></p> </td> <td> <p><code>{"bool" : {"must_not" : {"bool" : {"should" : {"field" : {"name" : "?"}}}}}}</code></p> </td> </tr> <tr> <td> <p><code>Near</code></p> </td> <td> <p><code>findByStoreNear</code></p> </td> <td> <p><code>Not Supported Yet !</code></p> </td> </tr> <tr> <td> <p><code>True</code></p> </td> <td> <p><code>findByAvailableTrue</code></p> </td> <td> <p><code>{"bool" : {"must" : {"field" : {"available" : true}}}}</code></p> </td> </tr> <tr> <td> <p><code>False</code></p> </td> <td> <p><code>findByAvailableFalse</code></p> </td> <td> <p><code>{"bool" : {"must" : {"field" : {"available" : false}}}}</code></p> </td> </tr> <tr> <td> <p><code>OrderBy</code></p> </td> <td> <p><code>findByAvailableTrueOrderByNameDesc</code></p> </td> <td> <p><code>{"sort" : [{ "name" : {"order" : "desc"} }],"bool" : {"must" : {"field" : {"available" : true}}}}</code></p> </td> </tr> </tbody> </table> <h3>六、between使用注意</h3> <p>&nbsp; 在使用的时候没有找到直接的例子，由于between是转换成range，所以需要范围参数from和to，</p> <p>&nbsp;举例如下：</p> <pre class="has"><code class="language-html">Page&lt;Recruit&gt; findByRecruitWorkAndRecruitCitysAndWorkTypeAndXjTimeBetween(String recruitWork, String recruitCitys, Integer workType, Date fromXjTime, Date toXjTime,Pageable pageable);</code></pre> <p><strong>注意：</strong>这里必须要注意的是：只要使用了between参数，****<strong>XjTimeBetween(......,from,to) ，使用该方法的时候，必须要传递范围参数from，to，不能同时为空。</strong></p> <p><strong>否则异常</strong></p> <pre class="has"><code class="language-java">&lt;strong&gt;org.springframework.dao.InvalidDataAccessApiUsageException: Range [* TO *] is not allowed&lt;/strong&gt;  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.data.elasticsearch.core.query.Criteria.between(Criteria.java:304)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.data.elasticsearch.repository.query.parser.ElasticsearchQueryCreator.from(ElasticsearchQueryCreator.java:127)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.data.elasticsearch.repository.query.parser.ElasticsearchQueryCreator.and(ElasticsearchQueryCreator.java:76)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.data.elasticsearch.repository.query.parser.ElasticsearchQueryCreator.and(ElasticsearchQueryCreator.java:46)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.data.repository.query.parser.AbstractQueryCreator.createCriteria(AbstractQueryCreator.java:109)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.data.repository.query.parser.AbstractQueryCreator.createQuery(AbstractQueryCreator.java:88)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.data.repository.query.parser.AbstractQueryCreator.createQuery(AbstractQueryCreator.java:73)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.data.elasticsearch.repository.query.ElasticsearchPartQuery.createQuery(ElasticsearchPartQuery.java:102)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.data.elasticsearch.repository.query.ElasticsearchPartQuery.execute(ElasticsearchPartQuery.java:51)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:499)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:477)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:56)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.data.repository.core.support.SurroundingTransactionDetectorMethodInterceptor.invoke(SurroundingTransactionDetectorMethodInterceptor.java:57)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)  &nbsp;&nbsp;&nbsp;&nbsp;at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:213)  &nbsp;&nbsp;&nbsp;&nbsp;at com.sun.proxy.$Proxy86.findByRecruitWorkAndRecruitCitysAndWorkTypeAndXjTimeBetween(Unknown Source)  &nbsp;&nbsp;&nbsp;&nbsp;at com.zhimingdeng.service.impl.EsIndexServiceImpl.findByRecruitWorkAndRecruitCitysAndWorkTypeAndXjTimeBetween(EsIndexServiceImpl.java:155)</code></pre> <p><strong>因为底层要求参数不能同时为空</strong></p> <h3>七、es时间类型注意</h3> <p>　　&nbsp;对于Elasticsearch原生支持date类型，json格式通过字符来表示date类型。所以在用json提交日期至elasticsearch的时候，es会隐式转换，把es认为是date类型的字符串直接转为date类型，间字段内容实际上就是转换成long类型作为内部存储的(所以完全可以接受其他时间格式作为时间字段的内容)。至于什么样的字符串es会认为可以转换成date类型，<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html"  rel="nofollow">参考elasticsearch官网介绍</a></p> <p>　　date类型是包含时区信息的，如果我们没有在json代表日期的字符串中显式指定时区，对es来说没什么问题，但是对于我们来说可能会发现一些时间差8个小时的问题。</p> <p>　　Elastic本身有一种特殊的时间格式，其形式如"2016-01-25T00:00:00"，此格式为<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://zh.wikipedia.org/zh-cn/ISO_8601"  rel="nofollow">ISO8601标准</a>。具体时间日期格式要求可以参见<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=http://https//www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html"  rel="nofollow">es官方文档</a>。</p> <p>　　然而我们在计算日期间隔，甚至按日分类的时候，往往需要把这个String时间转化为Unix时间戳(<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://en.wikipedia.org/wiki/Unix_time"  rel="nofollow">Unix Timestamp(时间戳)</a>)的形式,再进行计算。而通常，这个时间戳会以毫秒的形式(Java)保存在一个long类型里面，这就涉及到了String与long类型的相互转化。</p> <p>　　此外在使用Java Client聚合查询日期的时候，需要注意时区问题，因为默认的es是按照UTC标准时区算的，所以不设置的聚合统计结果是不正确的。默认不设置时区参数，es是安装UTC的时间进行查询的，所以分组的结果可能与预期不一样。</p> <p><code>　　JSON</code>&nbsp;没有日期类型，因此在 Elasticsearch 中可以表达成:</p> <ol> <li>日期格式化的字符串，比如: "2018-01-01" 或者 "2018/01/01 01:01:30";</li> <li>毫秒级别的<code>long</code>&nbsp;类型或秒级别的<code>integer</code>&nbsp;类型，比如: 1515150699465, 1515150699;</li> </ol> <p>　　实际上不管日期以何种格式写入，在 ES 内部都会先穿换成 UTC 时间并存储为<code>long</code>&nbsp;类型。日期格式可以自定义，如果没有指定的话会使用以下的默认格式:</p> <p><code>　　"strict_date_optional_time||epoch_millis"</code></p> <p>　　因此总结来说，不管哪种可以表示时间的格式写入，都可以用来表示时间</p> <p><strong>所以这里引出多种解决方案：</strong></p> <p>　　 1、es 默认的是 utc 时间，而国内服务器是 cst 时间，首先有时间上的差距需要转换。但是如果底层以及上层都统一用时间戳，完美解决时区问题。但是时间戳对我们来说不直观</p> <p>　　2、我们在往es提交日期数据的时候，直接提交带有时区信息的日期字符串，如：“2016-07-15T12:58:17.136+0800”</p> <p>　　3、还有另外的一种：</p> <p>　直接设置format为你想要的格式，比如 "<code>yyyy-MM-dd HH:mm:ss"</code>&nbsp;然后存储的时候，指定格式，并且Mapping&nbsp;&nbsp;也是指定相同的<code>format</code>&nbsp;。</p> <p>　　第一次使用方式：</p> <table border="0" cellpadding="0" cellspacing="0"> <tbody> <tr> <td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td> <td> <p><code></code><code>@Field</code><code>( type = FieldType.Date,</code></p> <p><code></code><code>format = DateFormat.custom,pattern = date_optional_time"</code></p> <p><code></code><code>)</code></p> <p><code>private</code><code>Date gmtCreate;</code></p> </td> </tr> </tbody> </table> <p>我这里是数据是从数据库直接读取，使用的datetime类型，原来直接使用的时候，抛异常：</p> <p><strong>　　MapperParsingException[failed to parse</strong>&nbsp;[***]];<strong>nested: IllegalArgumentException[Invalid format</strong>: "格式"];</p> <p>　　原因是： jackson库在转换为json的时候，将Date类型转为为了long型的字符串表示，而我们定义的是date_optional_time格式的字符串，所以解析错误，</p> <p>　　具体的解决办法：去掉注解中的format=DateFormat.date_optional_time，让其使用默认的格式，也就是&nbsp;'<strong>strict_date_optional_time||epoch_millis</strong>' , 既能接受<strong>date_optional_time</strong>格式的，也能接受epoch_millis格式，由于为了查看更直观感受改为如下：</p> <pre class="has"><code class="language-html">　　@Field( type = FieldType.Date,             format = DateFormat.custom,pattern = "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"     ) private Date gmtCreate;</code></pre> <p>&nbsp;改成这样后，底层多种格式都可以存储，如果没有根据时间进行范围查找，这里基本上已经就告一段落了。</p> <p><strong>时间范围查找需求：</strong><strong>存储Date，和取出来也是Dete</strong></p> <p>存储的时候利用各种JSON对象，如&nbsp;Jackson&nbsp;等。存储的时候就可以用JSON Format一下再存储，然后取出来后</p> <pre class="has"><code class="language-html">　　@Field( type = FieldType.Date,             format = DateFormat.custom,pattern = "yyyy-MM-dd HH:mm:ss"     )     @JsonFormat (shape = JsonFormat.Shape.STRING, pattern ="yyyy-MM-dd HH:mm:ss",timezone="GMT+8")     private Date xjTime;</code></pre> <p>&nbsp;有了这个注解后，</p> <pre class="has"><code class="language-html">　　　　timezone="GMT+8" 主要是因为底层存放的数据日期时区是UTC，这里转换成GMT</code></pre> <p>&nbsp;真实存储格式如下(高能瞎眼)：</p> <p><img decoding="async" alt="" class="has" src="http://img.555519.xyz/uploads3/20220602/47e7c2cac3ada8fc0d1517d69448620a.jpg"></p> <p><strong>时间范围查找需求注意：</strong></p> <p><strong>根据条件查询的时候，时间范围需要传入range，这里涉及到了两种选择，底层查询方法实现的时候range的参数为</strong></p> <p><strong>　1.date:</strong></p> <p><strong></strong>传入的是date参数，然后就行查询的时候，会报异常，因为我把日期转成了<strong>yyyy-MM-dd HH:mm:ss</strong>,但是底层数据是<strong>2018-03-27T16:00:00.000Z</strong>这种格式，导致错误，详细异常如下</p> <pre class="has"><code class="language-java">org.elasticsearch.action.search.SearchPhaseExecutionException: all shards failed  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.action.search.AbstractSearchAsyncAction.onFirstPhaseResult(AbstractSearchAsyncAction.java:206)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.action.search.AbstractSearchAsyncAction$1.onFailure(AbstractSearchAsyncAction.java:152)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.action.ActionListenerResponseHandler.handleException(ActionListenerResponseHandler.java:46)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.transport.TransportService$DirectResponseChannel.processException(TransportService.java:855)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.transport.TransportService$DirectResponseChannel.sendResponse(TransportService.java:833)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.transport.TransportService$4.onFailure(TransportService.java:387)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:39)  &nbsp;&nbsp;&nbsp;&nbsp;at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)  &nbsp;&nbsp;&nbsp;&nbsp;at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)  &nbsp;&nbsp;&nbsp;&nbsp;at java.lang.Thread.run(Thread.java:745)  &lt;strong&gt;Caused by: org.elasticsearch.ElasticsearchParseException: failed to parse date field [2018-03-27T16:00:00.000Z] with format [yyyy-MM-dd HH:mm:ss]&lt;/strong&gt;  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.common.joda.DateMathParser.parseDateTime(DateMathParser.java:203)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.common.joda.DateMathParser.parse(DateMathParser.java:67)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.index.mapper.core.DateFieldMapper$DateFieldType.parseToMilliseconds(DateFieldMapper.java:451)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.index.mapper.core.DateFieldMapper$DateFieldType.innerRangeQuery(DateFieldMapper.java:435)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.index.mapper.core.DateFieldMapper$DateFieldType.access$000(DateFieldMapper.java:199)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.index.mapper.core.DateFieldMapper$DateFieldType$LateParsingQuery.rewrite(DateFieldMapper.java:224)  &nbsp;&nbsp;&nbsp;&nbsp;at org.apache.lucene.search.BooleanQuery.rewrite(BooleanQuery.java:278)  &nbsp;&nbsp;&nbsp;&nbsp;at org.apache.lucene.search.IndexSearcher.rewrite(IndexSearcher.java:837)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.search.internal.ContextIndexSearcher.rewrite(ContextIndexSearcher.java:81)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.search.internal.DefaultSearchContext.preProcess(DefaultSearchContext.java:231)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.search.query.QueryPhase.preProcess(QueryPhase.java:103)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.search.SearchService.createContext(SearchService.java:676)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.search.SearchService.createAndPutContext(SearchService.java:620)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.search.SearchService.executeDfsPhase(SearchService.java:264)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.search.action.SearchServiceTransportAction$SearchDfsTransportHandler.messageReceived(SearchServiceTransportAction.java:360)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.search.action.SearchServiceTransportAction$SearchDfsTransportHandler.messageReceived(SearchServiceTransportAction.java:357)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.transport.TransportRequestHandler.messageReceived(TransportRequestHandler.java:33)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.transport.RequestHandlerRegistry.processMessageReceived(RequestHandlerRegistry.java:75)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.transport.TransportService$4.doRun(TransportService.java:376)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37)  &nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;3&nbsp;common frames omitted  &lt;strong&gt;Caused by: java.lang.IllegalArgumentException: Invalid format:&nbsp;"2018-03-27T16:00:00.000Z"&nbsp;is malformed at&nbsp;"T16:00:00.000Z"&lt;/strong&gt;  &nbsp;&nbsp;&nbsp;&nbsp;at org.joda.time.format.DateTimeParserBucket.doParseMillis(DateTimeParserBucket.java:187)  &nbsp;&nbsp;&nbsp;&nbsp;at org.joda.time.format.DateTimeFormatter.parseMillis(DateTimeFormatter.java:826)  &nbsp;&nbsp;&nbsp;&nbsp;at org.elasticsearch.common.joda.DateMathParser.parseDateTime(DateMathParser.java:200)  &nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;22&nbsp;common frames omitted</code></pre> <p><strong>实现参考：</strong><strong>解决：传入的date参数格式化成底层的类型</strong></p> <pre class="has"><code class="language-html">Page&lt;Recruit&gt; findByRecruitWorkAndRecruitCitysAndWorkTypeAndXjTimeBetween(String recruitWork, String recruitCitys, Integer workType, Date fromXjTime, Date toXjTime,Pageable pageable);</code></pre> <p><strong>&nbsp; 2.String:</strong></p> <p>&nbsp;参数直接使用string，避免上层转换成不合适的时间格式，使用框架底层自己转换，避免错误。</p> <pre class="has"><code class="language-html">实现参考：</code></pre> <pre class="has"><code class="language-html">Page&lt;Recruit&gt; findByRecruitWorkAndRecruitCitysAndWorkTypeAndXjTimeBetween(String recruitWork, String recruitCitys, Integer workType, String fromXjTime, String toXjTime,Pageable pageable);</code></pre> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html#strict-date-time"  rel="nofollow">es时间自定义类型</a></p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://stackoverflow.com/questions/29122071/elasticsearch-failed-to-parse-date"  rel="nofollow">https://stackoverflow.com/questions/29122071/elasticsearch-failed-to-parse-date</a></p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://stackoverflow.com/questions/29496081/spring-data-elasticsearchs-field-annotation-not-working"  rel="nofollow">https://stackoverflow.com/questions/29496081/spring-data-elasticsearchs-field-annotation-not-working</a></p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://stackoverflow.com/questions/32042430/elasticsearch-spring-data-date-format-always-is-long"  rel="nofollow">https://stackoverflow.com/questions/32042430/elasticsearch-spring-data-date-format-always-is-long</a></p> <h3>八、使用注意</h3> <p>　　个人认为springboot 这种集成es的方法，最大的优点是开发速度快，不要求对es一些api要求熟悉，能快速上手，即使之前对es不胜了解，也能通过方法名或者sql快速写出自己需要的逻辑，而具体转换成api层的操作，则有框架底层帮你实现。</p> <p>　　缺点也显而易见首先，使用的springboot的版本对es的版本也有了要求，不能超过es的某些版本号，部署时需要注意。第二，速度提升的同时，也失去了一些实用api的灵活性。一些比较灵活的条件封装不能很容易的实现。各有利弊，各位权衡。</p> <blockquote> <p><em>原文地址：http://www.cnblogs.com/guozp/p/8686904.html</em></p> </blockquote> </div> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-74663.htm">养猫的人容易得15种病疾病（养猫可能引起的疾病）</a></p>
                                        <p>下一个：<a href="/news/article-75331.htm">2022Vue.js 面试题汇总及答案</a></p>
                                    </div>
                                    </div>
                    <div class="col-md-3">
                        <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/free-nodes/2025-1-17-linux-surfboard-node.htm" title="1月17日 - 最高速度20.6M/S，2025年Surfboard每天更新免费节点订阅链接，干净IP机场推荐">1月17日 - 最高速度20.6M/S，2025年Surfboard每天更新免费节点订阅链接，干净IP机场推荐</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-1-4-free-high-speed-nodes.htm" title="1月4日 - 最高速度20.4M/S，2025年Surfboard每天更新免费节点订阅链接，干净IP机场推荐">1月4日 - 最高速度20.4M/S，2025年Surfboard每天更新免费节点订阅链接，干净IP机场推荐</a></li>
                        <li class="py-2"><a href="/news/article-66820.htm" title="动物疫苗公司排名前十（动物疫苗上市公司排名）">动物疫苗公司排名前十（动物疫苗上市公司排名）</a></li>
                        <li class="py-2"><a href="/news/article-56729.htm" title="宠物零食加工厂都需要什么执照 宠物零食加工厂都需要什么执照呢">宠物零食加工厂都需要什么执照 宠物零食加工厂都需要什么执照呢</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-2-9-node-share.htm" title="2月9日 - 最高速度22.1M/S，2025年Surfboard每天更新免费节点订阅链接，干净IP机场推荐">2月9日 - 最高速度22.1M/S，2025年Surfboard每天更新免费节点订阅链接，干净IP机场推荐</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-2-23-free-subscribe-node.htm" title="2月23日 - 最高速度20M/S，2025年Surfboard每天更新免费节点订阅链接，干净IP机场推荐">2月23日 - 最高速度20M/S，2025年Surfboard每天更新免费节点订阅链接，干净IP机场推荐</a></li>
                        <li class="py-2"><a href="/news/article-71332.htm" title="延吉延农动物医院好吗知乎 延吉延农动物医院好吗知乎">延吉延农动物医院好吗知乎 延吉延农动物医院好吗知乎</a></li>
                        <li class="py-2"><a href="/news/article-51289.htm" title="领养宠物赚钱软件是哪个 领养宠物赚钱软件是哪个软件">领养宠物赚钱软件是哪个 领养宠物赚钱软件是哪个软件</a></li>
                        <li class="py-2"><a href="/news/article-60747.htm" title="给动物打疫苗在哪里打的（动物疫苗哪里买）">给动物打疫苗在哪里打的（动物疫苗哪里买）</a></li>
                        <li class="py-2"><a href="/news/article-39318.htm" title="长沙宠物救助站地址（长沙宠物救助站地址在哪里）">长沙宠物救助站地址（长沙宠物救助站地址在哪里）</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">57</span> <a href="/date/2025-03/" title="2025-03 归档">2025-03</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">84</span> <a href="/date/2025-02/" title="2025-02 归档">2025-02</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">84</span> <a href="/date/2025-01/" title="2025-01 归档">2025-01</a></h4>
            </li>
                    </ul>
    </div>
</div>

                    </div>
                </div>
            </div>
        </section><!-- End About Section -->
    </main><!-- End #main -->
        <!-- ======= Footer ======= -->
    <footer id="footer" class="footer">
        <div class="footer-legal text-center">
            <div class="container d-flex flex-column flex-lg-row justify-content-center justify-content-lg-between align-items-center">
                <div class="d-flex flex-column align-items-center align-items-lg-start">
                    <div class="copyright">
                                <p>
                                    <a href="/">首页</a> | 
                                    <a href="/free-node/">免费节点</a> | 
                                    <a href="/news/">新闻资讯</a> |
                                    <a href="/about-us.htm">关于我们</a> |
                                    <a href="/disclaimer.htm">免责申明</a> |
                                    <a href="/privacy.htm">隐私申明</a> |
                                    <a href="/sitemap.xml">网站地图</a>
                                </p>
                        <a href="/">Free Surfboard官方订阅站</a> 版权所有 Powered by WordPress
                    </div>
                </div>
            </div>
        </div>
    </footer><!-- End Footer -->
    <a href="#" class="scroll-top d-flex align-items-center justify-content-center"><i class="bi bi-arrow-up-short"></i></a>
    <div id="preloader"></div>
    <!-- Vendor JS Files -->
    <script src="/assets/website/js/frontend/freesurfboard/jquery-3.2.1.min.js"></script>
    <script src="/assets/website/js/frontend/freesurfboard/bootstrap/js/bootstrap.bundle.min.js"></script>
    <script src="/assets/website/js/frontend/freesurfboard/aos/aos.js"></script>
    <script src="/assets/website/js/frontend/freesurfboard/isotope-layout/isotope.pkgd.min.js"></script>
    <script src="/assets/website/js/frontend/freesurfboard/swiper/swiper-bundle.min.js"></script>
    <script src="/assets/website/js/frontend/freesurfboard/php-email-form/validate.js"></script>
    <!-- Template Main JS File -->
    <script src="/assets/website/js/frontend/freesurfboard/main.js"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script>
    <script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>