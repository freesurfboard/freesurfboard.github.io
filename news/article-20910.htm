<!DOCTYPE html>
<html lang="zh-CN">

<head>
        <link rel="canonical" href="https://freesurfboard.github.io/news/article-20910.htm" />
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>数据结构 &#8211; 单链表 C++ 实现</title>
        <meta name="description" content="单链表的定义 typedef int ElemType; typedef struct LNode {     ElemType data;     LNode *next; } LNode, *Li" />
        <link rel="icon" href="__ADDON__/img/freesurfboard/favicon.ico" type="image/x-icon"/>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&family=Poppins:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,600;0,700;1,300;1,400;1,600;1,700&display=swap" rel="stylesheet">
    <!-- Vendor CSS Files -->
    <link href="__ADDON__/js/frontend/freesurfboard/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="__ADDON__/js/frontend/freesurfboard/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
    <link href="__ADDON__/js/frontend/freesurfboard/aos/aos.css" rel="stylesheet">
    <link href="__ADDON__/js/frontend/freesurfboard/glightbox/css/glightbox.min.css" rel="stylesheet">
    <link href="__ADDON__/js/frontend/freesurfboard/swiper/swiper-bundle.min.css" rel="stylesheet">
    <!-- Variables CSS Files. Uncomment your preferred color scheme -->
    <link href="/assets/website/css/freesurfboard/variables.css" rel="stylesheet">
    <!-- Template Main CSS File -->
    <link href="/assets/website/css/freesurfboard/main.css" rel="stylesheet">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-GEDHRZQGGF"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GEDHRZQGGF');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
    <!-- ======= Header ======= -->
    <header id="header" class="header fixed-top" data-scrollto-offset="0">
        <div class="container-fluid d-flex align-items-center justify-content-between">
                        <a href="/" class="logo d-flex align-items-center scrollto me-auto me-lg-0">
                Free Surfboard
            </a>
                        <nav id="navbar" class="navbar">
                <ul>
                                        <li><a class="nav-link" href="/">首页</a></li>
                                        <li><a class="nav-link" href="/free-nodes/">免费节点</a></li>
                                        <li><a class="nav-link" href="/paid-subscribe/">推荐机场</a></li>
                                        <li><a class="nav-link" href="/news/">新闻资讯</a></li>
                                        <li><a class="nav-link" href="#">关于</a></li>
                    <li><a class="nav-link" href="#">联系</a></li>
                </ul>
                <i class="bi bi-list mobile-nav-toggle d-none"></i>
            </nav><!-- .navbar -->
        </div>
    </header><!-- End Header -->
    <main id="main">
        <!-- ======= Breadcrumbs ======= -->
        <div class="breadcrumbs">
            <div class="container">
                <div class="d-flex justify-content-between align-items-center">
                    <h1>数据结构 &#8211; 单链表 C++ 实现</h1>
                    <ol>
                        <li><a href="/">首页</a></li>
                        <li><a href="/news/">新闻资讯</a></li>
                        <li>正文</li>
                    </ol>
                </div>
            </div>
        </div><!-- End Breadcrumbs -->
        <!-- ======= About Section ======= -->
        <section id="about" class="about">
            <div class="container" data-aos="fade-up">
                <div class="row">
                    <div class="col-md-9">
                                          				  				  				</h1> <h2 id="单链表的定义">单链表的定义</h2> <pre><code class="language-cpp">typedef int ElemType; typedef struct LNode {     ElemType data;     LNode *next; } LNode, *LinkList;</code></pre> <p>此处<code>LNode</code> 强调一个结点，<code>*LinkList</code> 强调一个单链表的头指针，本例中只有头指针使用<code>*LinkList</code>&nbsp;；</p> <h2 id="单链表的头指针和头节点">单链表的头指针和头节点</h2> <p>若单链表没有头节点，那么单链表的头指针则<code>指向</code>链表的第一个元素；若由头节点，头指针指向头节点；例如头指针为 L；如果链表为空，则有<code>L == NULL</code>，若有头节点，则有<code>L-&gt;next = NULL</code>；</p> <p>注意此处的指向问题应当透彻理解指针的概念，<code>指向</code>理解为元素地址；此处的 L 为头指针；在没有头节点时指向第一个元素，L 就是第一个元素的地址，若没有元素，即没有第一个元素，那么<code>L == NULL</code>；如果有头节点，那么 L 为头节点的地址，因此<code>L-&gt;next</code> 即为元素的第一个结点，故当链表为空时<code>L-&gt;next == NULL</code>；</p> <p>本例中的单链表均为带头节点的单链表；</p> <h2 id="初始化一个单链表">初始化一个单链表</h2> <blockquote> <p>初始化单链表的主要目的在于建立一个头节点，并让 L 指向头节点；</p> </blockquote> <p><code>L = (LinkList)malloc(sizeof(LNode))</code> 此处申请一个头节点的空间并返回申请到空间的地址返回，必须传入 L 的应用或者二级指针；</p> <p>若直接传入 L 那么将会拷贝一份 L 指针给 L1 ，那么申请到的空间地址将返回给 L1 而不是L，如下图</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220510/5aafc9d7fe70f1c32fa487fde69c6cbd.jpg" alt="数据结构 - 单链表 C++ 实现"></p> <p>因此必须传入 L 的引用或者 L 的指针；</p> <p>传入 L（无效）</p> <pre><code class="language-cpp">void ListInitite(LinkList L) {     L = (LinkList)malloc(sizeof(LNode));     L-&gt;next = NULL; }</code></pre> <p>传入引用</p> <pre><code class="language-cpp">void ListInitite(LinkList &amp;L) {     L = (LinkList)malloc(sizeof(LNode));     L-&gt;next = NULL; }</code></pre> <p>传入 L 的指针</p> <pre><code class="language-cpp">void ListInitite(LinkList *L) {     *L = (LinkList)malloc(sizeof(LNode));     (*L)-&gt;next = NULL; }</code></pre> <h2 id="创建一个单链表">创建一个单链表</h2> <h3 id="头插法">头插法</h3> <blockquote> <p>即将新元素插入到链表的第一个位置</p> </blockquote> <pre><code class="language-cpp">void List_HeadInsert(LinkList &amp;L) {     for(int i = 1; i &lt;= 10; i++) { //将 1 ~ 10 按头插法插入单链表         LNode* p = (LNode*)malloc(sizeof(LNode));         p-&gt;data = i;         p-&gt;next = L-&gt;next;         L-&gt;next = p;     }     //按照头插法的插入方式结果为倒序     Show_List(L); }</code></pre> <p>测试本段代码</p> <pre><code class="language-cpp">#include&lt;iostream&gt; #include&lt;cstdlib&gt; using namespace std;   typedef int ElemType; typedef struct LNode {     ElemType data;     struct LNode *next; } LNode, *LinkList;  void ListInitite(LinkList &amp;L) {     L = (LinkList)malloc(sizeof(LNode));     L-&gt;next = NULL; }  void Show_List(LinkList L) {     LNode* p = L-&gt;next;     while (p)     {         printf("%d ", p-&gt;data);         p = p-&gt;next;     } }  void List_HeadInsert(LinkList &amp;L) {     for(int i = 1; i &lt;= 10; i++) { //将 1 ~ 10 按头插法插入单链表         LNode* p = (LNode*)malloc(sizeof(LNode));         p-&gt;data = i;         p-&gt;next = L-&gt;next;         L-&gt;next = p;     }     //按照头插法的插入方式结果为倒序     Show_List(L); }  int main() {     LinkList L;     ListInitite(L);     List_HeadInsert(L);     return 0; }</code></pre> <p>运行结果</p> <pre><code class="language-cpp">10 9 8 7 6 5 4 3 2 1</code></pre> <h3 id="尾插法">尾插法</h3> <blockquote> <p>即新的元素放在链表尾</p> </blockquote> <p>使用尾插法，需要定义一个尾指针 r，尾指针始终指向链表的最后一个元素；刚开始为空链表，尾指针指向头节点，即和 L 相等，此后每插入一个新的结点，新的结点成为新的尾结点，r 指向此结点；</p> <pre><code class="language-cpp">void List_TailInsert(LinkList &amp;L) {     LNode* r = L;     for(int i = 1; i &lt;= 10; i++) {         LNode* p = (LNode*)malloc(sizeof(LNode));         p-&gt;data = i;         p-&gt;next = r-&gt;next;         r-&gt;next = p;         r = p;     } }</code></pre> <p>测试：</p> <pre><code class="language-cpp">#include&lt;iostream&gt; #include&lt;cstdlib&gt; using namespace std;  typedef int ElemType; typedef struct LNode {     ElemType data;     struct LNode *next; } LNode, *LinkList;  void ListInitite(LinkList &amp;L) {     L = (LinkList)malloc(sizeof(LNode));     L-&gt;next = NULL; }  void Show_List(LinkList L) {     LNode* p = L-&gt;next;     while (p)     {         printf("%d ", p-&gt;data);         p = p-&gt;next;     } }  void List_HeadInsert(LinkList &amp;L) {     for(int i = 1; i &lt;= 10; i++) { //将 1 ~ 10 按头插法插入单链表         LNode* p = (LNode*)malloc(sizeof(LNode));         p-&gt;data = i;         p-&gt;next = L-&gt;next;         L-&gt;next = p;     }     //按照头插法的插入方式结果为倒序     Show_List(L); }  void List_TailInsert(LinkList &amp;L) {     LNode* r = L;     for(int i = 1; i &lt;= 10; i++) {         LNode* p = (LNode*)malloc(sizeof(LNode));         p-&gt;data = i;         p-&gt;next = r-&gt;next;         r-&gt;next = p;         r = p;     } }  int main() {     LinkList L;     ListInitite(L);     List_TailInsert(L);     //按尾插法插入为顺序      Show_List(L);     return 0; }</code></pre> <p>测试结果：</p> <pre><code class="language-cpp">1 2 3 4 5 6 7 8 9 10</code></pre> <h2 id="返回链表的长度">返回链表的长度</h2> <pre><code class="language-cpp">int Length(LinkList L) {     LNode* p = L;     int length = 0;     while (p-&gt;next) {         length++;         p = p-&gt;next;     }     return length; }</code></pre> <h2 id="链表的查询">链表的查询</h2> <h3 id="按序号查找结点的值">按序号查找结点的值</h3> <blockquote> <p>即查找第 i 个结点的值，最终返回此结点</p> </blockquote> <pre><code class="language-cpp">LNode* GetElem(LinkList L, int i) {     if(i == 0) {         return L;     }     if(i &lt; 1 || i &gt; Length(L)) {   //若超出链表范围         return NULL;     }     LNode* p = L;     int now = 0;     while(p &amp;&amp; now &lt; i) {         p = p-&gt;next;         now++;     }     return p; }</code></pre> <p>测试：</p> <pre><code class="language-cpp">#include&lt;iostream&gt; #include&lt;cstdlib&gt; using namespace std;  typedef int ElemType; typedef struct LNode {     ElemType data;     struct LNode *next; } LNode, *LinkList;  void ListInitite(LinkList &amp;L) {     L = (LinkList)malloc(sizeof(LNode));     L-&gt;next = NULL; }  void Show_List(LinkList L) {     LNode* p = L-&gt;next;     while (p)     {         printf("%d ", p-&gt;data);         p = p-&gt;next;     } }  void List_TailInsert(LinkList &amp;L) {     LNode* r = L;     for(int i = 1; i &lt;= 10; i++) {         LNode* p = (LNode*)malloc(sizeof(LNode));         p-&gt;data = i;         p-&gt;next = r-&gt;next;         r-&gt;next = p;         r = p;     } }  int Length(LinkList L) {     LNode* p = L;     int length = 0;     while (p-&gt;next) {         length++;         p = p-&gt;next;     }     return length; }   LNode* GetElem(LinkList L, int i) {     if(i == 0) {         return L;     }     if(i &lt; 1 || i &gt; Length(L)) {   //若超出链表范围         return NULL;     }     LNode* p = L;     int now = 0;     while(p &amp;&amp; now &lt; i) {         p = p-&gt;next;         now++;     }     return p; }   int main() {     LinkList L;     ListInitite(L);     List_TailInsert(L);     LNode* ip = GetElem(L, 5);     Show_List(L);     if(ip) {         printf("\n%d", ip-&gt;data);     }     return 0; }</code></pre> <p>测试结果：</p> <pre><code class="language-cpp">1 2 3 4 5 6 7 8 9 10 5</code></pre> <h3 id="按值查找结点">按值查找结点</h3> <pre><code class="language-cpp">LNode* LocateElem(LinkList L, ElemType e) {     LNode* p = L-&gt;next;     while(p &amp;&amp; p-&gt;data != e) {         p = p-&gt;next;     }     return p; }</code></pre> <h2 id="插入结点">插入结点</h2> <blockquote> <p>在链表的第 i 个位置插入元素 e</p> </blockquote> <p>插入新的元素后共有 len + 1 个元素，插入位置也必须在 [1, len + 1]，因此插入位置必须在这个范围内；首先获得第 i - 1 个结点，然后进行操作；</p> <pre><code class="language-cpp">bool ListInsert(LinkList &amp;L, int i, ElemType e) {     if(i &lt; 1 || i &gt; Length(L) + 1) {         printf("插入位置错误\n");         return false;     }     LNode *pre, *s;     s-&gt;data = e;     pre = GetElem(L, i - 1);     s-&gt;next = pre-&gt;next;     pre-&gt;next = s;     return true; }</code></pre> <p>测试代码：</p> <pre><code class="language-cpp">#include&lt;iostream&gt; #include&lt;cstdlib&gt; using namespace std;  typedef int ElemType; typedef struct LNode { 	ElemType data; 	struct LNode *next; } LNode, *LinkList;  void ListInitite(LinkList &amp;L) { 	L = (LinkList)malloc(sizeof(LNode)); 	L-&gt;next = NULL; }  void Show_List(LinkList L) { 	LNode* p = L-&gt;next; 	while (p) { 		printf("%d ", p-&gt;data); 		p = p-&gt;next; 	} }  void List_HeadInsert(LinkList &amp;L) { 	for(int i = 1; i &lt;= 10; i++) { //将 1 ~ 10 按头插法插入单链表 		LNode* p = (LNode*)malloc(sizeof(LNode)); 		p-&gt;data = i; 		p-&gt;next = L-&gt;next; 		L-&gt;next = p; 	} }   int Length(LinkList L) { 	LNode* p = L-&gt;next; 	int length = 0; 	while(p) { 		length++; 		p = p-&gt;next; 	} 	return length; }   LNode* GetElem(LinkList L, int i) { 	if(i == 0) { 		return L; 	} 	if(i &lt; 1 || i &gt; Length(L)) {   //若超出链表范围 		return NULL; 	} 	LNode* p = L; 	int now = 0; 	while(p &amp;&amp; now &lt; i) { 		p = p-&gt;next; 		now++; 	} 	return p; }   bool ListInsert(LinkList &amp;L, int i, ElemType e) {     if(i &lt; 1 || i &gt; Length(L) + 1) {         printf("插入位置错误\n");         return false;     }     LNode *pre = GetElem(L, i - 1);     LNode *s = (LNode*)malloc(sizeof(LNode));     s-&gt;data = e;     s-&gt;next = pre-&gt;next;     pre-&gt;next = s;     return true; }  int main() { 	LinkList L; 	ListInitite(L); 	List_HeadInsert(L); 	ListInsert(L, 5, 100); 	Show_List(L); 	return 0; }</code></pre> <p>测试结果：</p> <pre><code class="language-cpp">10 9 8 7 100 6 5 4 3 2 1</code></pre> <h3 id="前插和后插">前插和后插</h3> <blockquote> <p>前插即在一个<strong>已知结点</strong>的前面插入新的结点，后插即在一个已知结点的后面插入新的结点；</p> </blockquote> <p>上面的插入函数即在结点的后面插入新的结点，首先需要得到第 i - 1 个结点，然后再此结点后面插入新的结点，即为后插；</p> <p>前插操作也是类似，在某个结点的前面插入结点，首先获取到此结点的前一个结点，然后在前一个结点后面插入新的结点；但这种插入方式必须首先获取到已知结点的前一个结点，查找过程必须遍历当前结点之前的所有元素才能找到前一个结点；时间复杂度为 O(n)，采用另一种方式可以巧妙的将复杂度降低到 O(1)；方法为在已知结点的后面插入新的结点，然后交换新节点与已知结点的值，就实现了相同的目的；</p> <pre><code class="language-cpp">void FrontInsert(LNode* node, ElemType e) {     LNode *s = (LNode*)malloc(sizeof(LNode));     s-&gt;data = e;     s-&gt;next = node-&gt;next;     node-&gt;next = s;     ElemType temp = node-&gt;data;     node-&gt;data = s-&gt;data;     s-&gt;data = temp; }</code></pre> <blockquote> <p>2~5 行操作为将新的结点插入到已知结点的后面，6~8 行操作为交换两个结点内的值；</p> </blockquote> <p>测试：</p> <pre><code class="language-cpp">#include&lt;iostream&gt; #include&lt;cstdlib&gt; using namespace std;  typedef int ElemType; typedef struct LNode {     ElemType data;     struct LNode *next; } LNode, *LinkList;  void ListInitite(LinkList &amp;L) {     L = (LinkList)malloc(sizeof(LNode));     L-&gt;next = NULL; }  void Show_List(LinkList L) {     LNode* p = L-&gt;next;     while (p)     {         printf("%d ", p-&gt;data);         p = p-&gt;next;     } }  void List_HeadInsert(LinkList &amp;L) {     for(int i = 1; i &lt;= 10; i++) { //将 1 ~ 10 按头插法插入单链表         LNode* p = (LNode*)malloc(sizeof(LNode));         p-&gt;data = i;         p-&gt;next = L-&gt;next;         L-&gt;next = p;     } }   int Length(LinkList L) {     LNode* p = L-&gt;next;     int length = 0;     while(p) {         length++;         p = p-&gt;next;     }     return length; }   LNode* GetElem(LinkList L, int i) {     if(i == 0) {         return L;     }     if(i &lt; 1 || i &gt; Length(L)) {   //若超出链表范围         return NULL;     }     LNode *p = L;     int now = 0;     while(p &amp;&amp; now &lt; i) {         p = p-&gt;next;         now++;     }     return p; }   void FrontInsert(LNode* &amp;node, ElemType e) {     LNode *s = (LNode*)malloc(sizeof(LNode));     s-&gt;data = e;     s-&gt;next = node-&gt;next;     node-&gt;next = s;     ElemType temp = node-&gt;data;     node-&gt;data = s-&gt;data;     s-&gt;data = temp; }   int main() {     LinkList L;     ListInitite(L);     List_HeadInsert(L);     Show_List(L);     LNode *node = GetElem(L, 5);     FrontInsert(node, 50);     printf("\n");     Show_List(L);     return 0; }</code></pre> <p>测试结果：</p> <pre><code class="language-cpp">10 9 8 7 6 5 4 3 2 1 10 9 8 7 50 6 5 4 3 2 1</code></pre> <h2 id="删除结点操作">删除结点操作</h2> <blockquote> <p>删除链表位置为 i 的结点，并将删除的结点存放在 node 中</p> </blockquote> <pre><code class="language-cpp">bool ListDelete(LinkList &amp;L, int i, LNode* &amp;node) {     if(i &lt; 1 || i &gt; Length(L)) {         printf("删除位置错误");         return false;     }     LNode *p = GetElem(L, i - 1);     LNode *q = p-&gt;next;     p-&gt;next = q-&gt;next;     node = q;     free(q);     return true; }</code></pre> <p>上述代码有错，free(void* p) 函数的作用是回收 动态分配给 p 的空间，不论有多少指针指向 p 所指向的空间，因此将对于<code>node = q</code>，在<code>free(q)</code> 以后 node 所指向的空间也被回收了，因此此处最好不返回结点，返回结点中的值；修正后的代码如下：</p> <pre><code class="language-cpp">bool ListDelete(LinkList &amp;L, int i, ElemType &amp;del) {     if(i &lt; 1 || i &gt; Length(L)) {         printf("删除位置错误");         return false;     }     LNode *p = GetElem(L, i - 1);     LNode *q = p-&gt;next;     p-&gt;next = q-&gt;next;     del = q-&gt;data;     free(q);     return true; }</code></pre> <p>测试：</p> <pre><code class="language-cpp">#include&lt;iostream&gt; #include&lt;cstdlib&gt; using namespace std;  typedef int ElemType; typedef struct LNode {     ElemType data;     struct LNode *next; } LNode, *LinkList;  void ListInitite(LinkList &amp;L) {     L = (LinkList)malloc(sizeof(LNode));     L-&gt;next = NULL; }  void Show_List(LinkList L) {     LNode* p = L-&gt;next;     while (p)     {         printf("%d ", p-&gt;data);         p = p-&gt;next;     } }  void List_TailInsert(LinkList &amp;L) {     LNode* r = L;     for(int i = 1; i &lt;= 10; i++) {         LNode* p = (LNode*)malloc(sizeof(LNode));         p-&gt;data = i;         p-&gt;next = r-&gt;next;         r-&gt;next = p;         r = p;     } }  int Length(LinkList L) {     LNode* p = L-&gt;next;     int length = 0;     while(p) {         length++;         p = p-&gt;next;     }     return length; }   LNode* GetElem(LinkList L, int i) {     if(i == 0) {         return L;     }     if(i &lt; 1 || i &gt; Length(L)) {   //若超出链表范围         return NULL;     }     LNode *p = L;     int now = 0;     while(p &amp;&amp; now &lt; i) {         p = p-&gt;next;         now++;     }     return p; }   bool ListDelete(LinkList &amp;L, int i, ElemType &amp;del) {     if(i &lt; 1 || i &gt; Length(L)) {         printf("删除位置错误");         return false;     }     LNode *p = GetElem(L, i - 1);     LNode *q = p-&gt;next;     p-&gt;next = q-&gt;next;     del = q-&gt;data;     free(q);     return true; }  int main() {     LinkList L;     ListInitite(L);     List_TailInsert(L);     Show_List(L);     ElemType del;     ListDelete(L, 7, del);     printf("\n");     Show_List(L);     printf("\n删除的元素为：%d", del);     return 0; }</code></pre> <p>结果：</p> <pre><code class="language-cpp">1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 8 9 10 删除的元素为：7</code></pre> <p>此处删除的实现依然为后删，即找到将要删除结点的前一个结点进行删除；即给定一个已知结点需要对其进行删除，首先应该找到其前驱节点才能进行删除；和前插法类似，也有减少其复杂度的方法，即首先交换待删除结点后其后继节点的值，然后删除其后继节点；实现方式和前插法类似：</p> <pre><code class="language-cpp">void Del(LinkList &amp;L, LNode* &amp;p) {     LNode* q = p-&gt;next;     ElemType temp = q-&gt;data;     q-&gt;data = p-&gt;data;     p-&gt;data = temp;     p-&gt;next = q-&gt;next;     free(q); }</code></pre> <blockquote> <p>当然此时对于极端情况，即要删除的元素为最后一个元素时不适用；</p> </blockquote> <p>测试：</p> <pre><code class="language-cpp">#include&lt;iostream&gt; #include&lt;cstdlib&gt; using namespace std;  typedef int ElemType; typedef struct LNode {     ElemType data;     struct LNode *next; } LNode, *LinkList;  void ListInitite(LinkList &amp;L) {     L = (LinkList)malloc(sizeof(LNode));     L-&gt;next = NULL; }  void Show_List(LinkList L) {     LNode* p = L-&gt;next;     while (p)     {         printf("%d ", p-&gt;data);         p = p-&gt;next;     } }  void List_TailInsert(LinkList &amp;L) {     LNode* r = L;     for(int i = 1; i &lt;= 10; i++) {         LNode* p = (LNode*)malloc(sizeof(LNode));         p-&gt;data = i;         p-&gt;next = r-&gt;next;         r-&gt;next = p;         r = p;     } }  int Length(LinkList L) {     LNode* p = L-&gt;next;     int length = 0;     while(p) {         length++;         p = p-&gt;next;     }     return length; }   LNode* GetElem(LinkList L, int i) {     if(i == 0) {         return L;     }     if(i &lt; 1 || i &gt; Length(L)) {   //若超出链表范围         return NULL;     }     LNode *p = L;     int now = 0;     while(p &amp;&amp; now &lt; i) {         p = p-&gt;next;         now++;     }     return p; }    void Del(LinkList &amp;L, LNode* &amp;p) {     LNode* q = p-&gt;next;     ElemType temp = q-&gt;data;     q-&gt;data = p-&gt;data;     p-&gt;data = temp;     p-&gt;next = q-&gt;next;     free(q); }  int main() {     LinkList L;     ListInitite(L);     List_TailInsert(L);     Show_List(L); 	LNode *p = GetElem(L, 4); 	Del(L, p); 	printf("\n"); 	Show_List(L);     return 0; }</code></pre> <p>结果：</p> <pre><code class="language-cpp">1 2 3 4 5 6 7 8 9 10 1 2 3 5 6 7 8 9 10</code></pre> <h2 id="单链表的销毁">单链表的销毁</h2> <pre><code class="language-cpp">void Destory(LinkList &amp;L) {     LNode* p = L;     LNode* q = L;     while (q)     {         p = q;         q = q-&gt;next;         free(p);     }    free(L);      L=NULL; }</code></pre> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-20455.htm">宠物粮食加工厂加盟条件要求高吗 宠物粮食加工厂加盟条件要求高吗知乎</a></p>
                                        <p>下一个：<a href="/news/article-20911.htm">宠物店亏本了怎么办（现在宠物店生意亏死）</a></p>
                                    </div>
                                    </div>
                    <div class="col-md-3">
                        <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/free-nodes/2024-11-23-free-high-speed-nodes.htm" title="11月23日 - 最高速度21.7M/S，2024年Surfboard每天更新免费节点订阅链接，干净IP机场推荐">11月23日 - 最高速度21.7M/S，2024年Surfboard每天更新免费节点订阅链接，干净IP机场推荐</a></li>
                        <li class="py-2"><a href="/news/article-19990.htm" title="猫打不打疫苗有什么区别图片（宠物猫打不打疫苗）">猫打不打疫苗有什么区别图片（宠物猫打不打疫苗）</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-9-6-node-share.htm" title="9月6日 - 最高速度22.3M/S，2024年Surfboard每天更新免费节点订阅链接">9月6日 - 最高速度22.3M/S，2024年Surfboard每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-11-8-free-high-speed-nodes.htm" title="11月8日 - 最高速度21.1M/S，2024年Surfboard每天更新免费节点订阅链接，干净IP机场推荐">11月8日 - 最高速度21.1M/S，2024年Surfboard每天更新免费节点订阅链接，干净IP机场推荐</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-10-15-free-surfboard-node.htm" title="10月15日 - 最高速度21M/S，2024年Surfboard每天更新免费节点订阅链接，干净IP机场推荐">10月15日 - 最高速度21M/S，2024年Surfboard每天更新免费节点订阅链接，干净IP机场推荐</a></li>
                        <li class="py-2"><a href="/news/article-20910.htm" title="数据结构 &#8211; 单链表 C++ 实现">数据结构 &#8211; 单链表 C++ 实现</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-11-21-free-surfboard-node.htm" title="11月21日 - 最高速度22.9M/S，2024年Surfboard每天更新免费节点订阅链接，干净IP机场推荐">11月21日 - 最高速度22.9M/S，2024年Surfboard每天更新免费节点订阅链接，干净IP机场推荐</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-11-1-free-high-speed-nodes.htm" title="11月1日 - 最高速度22.2M/S，2024年Surfboard每天更新免费节点订阅链接，干净IP机场推荐">11月1日 - 最高速度22.2M/S，2024年Surfboard每天更新免费节点订阅链接，干净IP机场推荐</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-8-7-free-surfboard.htm" title="8月7日 - 最高速度20.1M/S，2024年Surfboard每天更新免费节点订阅链接">8月7日 - 最高速度20.1M/S，2024年Surfboard每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-10-1-free-node-subscribe-links.htm" title="10月1日 - 最高速度19.1M/S，2024年Surfboard每天更新免费节点订阅链接">10月1日 - 最高速度19.1M/S，2024年Surfboard每天更新免费节点订阅链接</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">12</span> <a href="/date/2024-12/" title="2024-12 归档">2024-12</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">32</span> <a href="/date/2024-11/" title="2024-11 归档">2024-11</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">31</span> <a href="/date/2024-10/" title="2024-10 归档">2024-10</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">30</span> <a href="/date/2024-09/" title="2024-09 归档">2024-09</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">31</span> <a href="/date/2024-08/" title="2024-08 归档">2024-08</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">6</span> <a href="/date/2024-07/" title="2024-07 归档">2024-07</a></h4>
            </li>
                    </ul>
    </div>
</div>

                    </div>
                </div>
            </div>
        </section><!-- End About Section -->
    </main><!-- End #main -->
    <!-- ======= Footer ======= -->
<footer id="footer" class="footer">
    <div class="footer-legal text-center">
        <div class="container d-flex flex-column flex-lg-row justify-content-center justify-content-lg-between align-items-center">
            <div class="d-flex flex-column align-items-center align-items-lg-start">
                <div class="copyright">
                    <a href="/">Free Surfboard官方订阅站</a> 版权所有 Powered by WordPress
                </div>
            </div>
        </div>
    </div>
</footer><!-- End Footer -->
<a href="#" class="scroll-top d-flex align-items-center justify-content-center"><i class="bi bi-arrow-up-short"></i></a>
<div id="preloader"></div>
<!-- Vendor JS Files -->
<script src="/assets/website/js/frontend/freesurfboard/jquery-3.2.1.min.js"></script>
<script src="/assets/website/js/frontend/freesurfboard/bootstrap/js/bootstrap.bundle.min.js"></script>
<script src="/assets/website/js/frontend/freesurfboard/aos/aos.js"></script>
<script src="/assets/website/js/frontend/freesurfboard/glightbox/js/glightbox.min.js"></script>
<script src="/assets/website/js/frontend/freesurfboard/isotope-layout/isotope.pkgd.min.js"></script>
<script src="/assets/website/js/frontend/freesurfboard/swiper/swiper-bundle.min.js"></script>
<script src="/assets/website/js/frontend/freesurfboard/php-email-form/validate.js"></script>
<!-- Template Main JS File -->
<script src="/assets/website/js/frontend/freesurfboard/main.js"></script>
<script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>